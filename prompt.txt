Esquema archivos:

│   main.py
│   
├───data
│       car_ratings.csv
│       coches.csv
│       collaborative_model.pkl
│       distance_cache.csv
│       
├───modules
│   │   collaborative_filter.py
│   │   content_filter.py
│   │   data_loader.py
│   │   geo_utils.py
│   │   hybrid_recommender.py
│


collaborative_filter.py

import pandas as pd
from surprise import Dataset, Reader, SVD
from surprise.model_selection import train_test_split
import pickle
import os

class CollaborativeFilter:
    def __init__(self, model_path='data/collaborative_model.pkl'):
        self.model_path = model_path
        self.model = None
        self.testset = None

    def train_model(self, ratings_path: str) -> None:
        """
        Entrena un modelo de filtrado colaborativo con Surprise o carga uno guardado.
        """
        if os.path.exists(self.model_path):
            print("Cargando modelo colaborativo guardado...")
            with open(self.model_path, 'rb') as model_file:
                self.model = pickle.load(model_file)
            return

        print("Entrenando un nuevo modelo colaborativo...")
        df_ratings = pd.read_csv(ratings_path)
        reader = Reader(rating_scale=(1, 5))
        data = Dataset.load_from_df(df_ratings[['user_id', 'model_id', 'rating']], reader)

        trainset, self.testset = train_test_split(data, test_size=0.2)

        best_params = {'n_factors': 20, 'n_epochs': 10, 'lr_all': 0.002, 'reg_all': 0.4}
        self.model = SVD(
            n_factors=best_params['n_factors'],
            n_epochs=best_params['n_epochs'],
            lr_all=best_params['lr_all'],
            reg_all=best_params['reg_all']
        )
        self.model.fit(trainset)

        with open(self.model_path, 'wb') as model_file:
            pickle.dump(self.model, model_file)

    def predict_rating(self, user_id: str, model_id: int) -> float:
        """
        Predice la valoración de un usuario para un modelo de coche.
        """
        if self.model is None:
            raise ValueError("El modelo no está entrenado.")
        prediction = self.model.predict(user_id, model_id)
        return prediction.est

content_filter.py

import pandas as pd
import numpy as np

class ContentFilter:
    @staticmethod
    def calculate_content_similarity(user_input: dict, car_data: pd.DataFrame, feature_weights: dict) -> pd.DataFrame:
        """
        Calcula la similitud entre las características deseadas por el usuario y los coches.

        :param user_input: Diccionario con las preferencias del usuario.
        :param car_data: DataFrame con los datos de los coches.
        :param feature_weights: Diccionario con los pesos asignados a cada característica.
        :return: DataFrame con un puntaje de similitud para cada coche.
        """
        car_data = car_data.copy()
        car_data['similarity_score'] = 0.0
        
        for feature, weight in feature_weights.items():
            if feature in user_input and user_input[feature] is not None:
                user_value = user_input[feature]
                
                if feature in ['price', 'year', 'kms', 'power']:  # Características numéricas
                    max_val = car_data[feature].max()
                    min_val = car_data[feature].min()
                    
                    # Penalización para price y kms si son mayores que el valor del usuario
                    if feature in ['price', 'kms']:
                        normalized_diff = np.where(car_data[feature] > user_value, 
                                                (car_data[feature] - user_value) / (max_val - user_value), 
                                                1.0)
                    else:  # Normalización directa para year y power
                        normalized_diff = np.where(car_data[feature] < user_value, 
                                                    (user_value - car_data[feature]) / (user_value - min_val), 
                                                    1.0)

                    car_data['similarity_score'] += normalized_diff * weight
                
                elif feature in ['fuel', 'shift', 'color', 'make', 'model', 'doors']:  # Características categóricas
                    car_data['similarity_score'] += car_data[feature].apply(
                        lambda x: weight if str(x).lower() == str(user_value).lower() else 0)
        # Ordenar por el puntaje de similitud en orden descendente
        return car_data.sort_values(by='similarity_score', ascending=False)


data_loader.py

import pandas as pd

def load_data(coches_path: str, ratings_path: str) -> tuple:
    """
    Carga los datasets de coches y valoraciones desde archivos CSV.
    
    :param coches_path: Ruta al archivo de coches.
    :param ratings_path: Ruta al archivo de valoraciones.
    :param sep: Separador del CSV.
    :return: Tuple (df_cars, df_ratings)
    """
    try:
        df_cars = pd.read_csv(coches_path)
        df_ratings = pd.read_csv(ratings_path)
        print("Datos cargados exitosamente.")
        return df_cars, df_ratings
    except Exception as e:
        print(f"Error al cargar los datos: {e}")
        raise

geo_utils.py

import pandas as pd
from geopy.distance import geodesic
from geopy.geocoders import Nominatim
import os

class GeoUtils:
    def __init__(self, user_agent="geo_calc", cache_file='data/distance_cache.csv'):
        self.geolocator = Nominatim(user_agent=user_agent)
        self.cache_file = cache_file
        self.distance_cache = {}
        self.cache_miss_message_shown = False
        self._load_cache()

    def _load_cache(self):
        if os.path.exists(self.cache_file):
            try:
                cache_df = pd.read_csv(self.cache_file)
                self.distance_cache = {
                    (row['origin'].lower(), row['destination'].lower()): row['distance_km']
                    for _, row in cache_df.iterrows()
                }
            except Exception as e:
                print(f"Error al cargar el caché: {e}. Se iniciará vacío.")

    def _save_cache(self):
        cache_data = [
            {"origin": origin, "destination": destination, "distance_km": round(distance, 2)}
            for (origin, destination), distance in self.distance_cache.items()
        ]
        cache_df = pd.DataFrame(cache_data)
        cache_df.to_csv(self.cache_file, index=False)

    def calculate_distance(self, origin, destination):
        origin = origin.lower()
        destination = destination.lower()

        if (origin, destination) in self.distance_cache or (destination, origin) in self.distance_cache:
            return self.distance_cache.get((origin, destination)) or self.distance_cache.get((destination, origin))
        if not self.cache_miss_message_shown:
            print("Distancia no encontrada en caché. Esto puede tardar unos segundos...")
            self.cache_miss_message_shown = True
        try:
            coords_origin = self.geolocator.geocode(origin)
            coords_dest = self.geolocator.geocode(destination)
            if coords_origin and coords_dest:
                distance = geodesic(
                    (coords_origin.latitude, coords_origin.longitude),
                    (coords_dest.latitude, coords_dest.longitude)
                ).kilometers
                self.distance_cache[(origin, origin)] = 0.0
                self.distance_cache[(origin, destination)] = distance
                self._save_cache()
                return distance
        except Exception as e:
            print(f"Error al calcular la distancia: {e}")

        return None

    def apply_penalty(self, car_data, user_location, distance_weight):
        max_distance = 500
        car_data['distance'] = car_data['province'].apply(lambda x: self.calculate_distance(user_location, x) or max_distance)
        car_data['geo_score'] = car_data['distance'].apply(lambda x: -distance_weight * (x / max_distance) if x < max_distance else -distance_weight)
        return car_data


hybrid_recommender.py

from .collaborative_filter import CollaborativeFilter
from .content_filter import ContentFilter
from .geo_utils import GeoUtils

class HybridRecommender:
    def __init__(self, collaborative_model: CollaborativeFilter, geo_calculator: GeoUtils):
        self.collaborative_model = collaborative_model
        self.geo_calculator = geo_calculator

    def recommend(self, user_id, user_input, feature_weights, user_location, cars_df):
        content_scores = ContentFilter.calculate_content_similarity(user_input, cars_df, feature_weights)
        geo_scores = self.geo_calculator.apply_penalty(content_scores, user_location, feature_weights.get('distance', 0))
        geo_scores['collaborative_score'] = geo_scores['model_id'].apply(lambda x: self.collaborative_model.predict_rating(user_id, x))
        
        geo_scores['hybrid_score'] = (
            geo_scores['similarity_score'] * 0.4 +
            geo_scores['collaborative_score'] * 0.4 +
            geo_scores['geo_score'] * 0.2
        )

        return geo_scores.sort_values('hybrid_score', ascending=False)


main.py

from modules.hybrid_recommender import HybridRecommender
from modules.collaborative_filter import CollaborativeFilter
from modules.geo_utils import GeoUtils
from modules.data_loader import load_data
import os

class CarRecommenderApp:
    def __init__(self):
        self.cars_path = 'data/coches.csv'
        self.ratings_path = 'data/car_ratings.csv'
        self.distance_cache = 'data/distance_cache.csv'
        self.user_id = 'new_user'

    def check_csv_files(self):
        files = [self.cars_path, self.ratings_path, self.distance_cache]
        missing_files = [file for file in files if not os.path.exists(file)]
        if missing_files:
            print(f"Faltan los siguientes archivos: {missing_files}")
            return False
        return True
    
    def get_user_input(self):
        """
        Solicita al usuario que ingrese sus preferencias para un coche y los pesos correspondientes.
        Incluye la ciudad obligatoria y la importancia de la distancia.
        
        :return: Diccionario con las características del coche, los pesos y la ubicación del usuario.
        """
        print("Introduce tus preferencias para un coche ideal:")
        
        # Características del coche
        user_input = {}
        feature_weights = {}

        # Solicitar características
        user_input['make'] = input("Marca del coche: ").strip()
        user_input['price'] = input("Precio del coche: ").strip()
        user_input['fuel'] = input("Tipo de combustible (Diesel, Gasolina, Eléctrico, Híbrido): ").strip()
        user_input['year'] = input("Año del coche: ").strip()
        user_input['kms'] = input("Kilometraje del coche: ").strip()
        user_input['power'] = input("Potencia del coche en caballos: ").strip()
        user_input['doors'] = input("Número de puertas (2, 3, 4, 5): ").strip()
        user_input['shift'] = input("Tipo de transmisión (Automático, Manual): ").strip()
        user_input['color'] = input("Color del coche: ").strip()

        # Convertir valores numéricos a enteros y vacíos a None
        for key, value in user_input.items():
            if value.isdigit():
                user_input[key] = int(value)
            elif value == "":
                user_input[key] = None

        # Solicitar ubicación obligatoria
        while True:
            user_location = input("Introduce tu ubicación (ciudad): ").strip().capitalize()
            if user_location:
                break
            print("La ubicación es obligatoria. Por favor, ingresa tu ciudad.")

        # Solicitar pesos para todas las características
        print("\nAhora, por favor, asigna un peso del 1 al 10 a cada característica que hayas seleccionado.")
        print("Si no has seleccionado una característica, pon un peso de 0 para esa opción.")
        
        # Pedir el peso para todas las características
        for key in user_input:
            if user_input[key] is not None:
                while True:
                    try:
                        weight = int(input(f"Peso para {key} (debe ser entre 0 y 10): "))
                        if 0 <= weight <= 10:
                            break
                        else:
                            print("El peso debe estar entre 0 y 10. Intenta de nuevo.")
                    except ValueError:
                        print("Por favor, ingresa un número válido entre 0 y 10.")
                feature_weights[key] = weight
            else:
                feature_weights[key] = 0

        # Solicitar importancia de la distancia (obligatoria)
        while True:
            try:
                distance_weight = int(input("¿Qué importancia le das a la distancia? (debe ser entre 0 y 10): "))
                if 0 <= distance_weight <= 10:
                    break
                else:
                    print("El peso debe estar entre 0 y 10. Intenta de nuevo.")
            except ValueError:
                print("Por favor, ingresa un número válido entre 0 y 10.")
        feature_weights['distance'] = distance_weight

        # Validar que se haya seleccionado al menos una característica
        if all(value == 0 for value in feature_weights.values()):
            print("Debes asignar al menos un peso mayor que 0 para realizar la recomendación.")
            return None, None, None

        return user_input, feature_weights, user_location




    def run(self):
        if not self.check_csv_files():
            exit()

        collaborative_model = CollaborativeFilter()
        collaborative_model.train_model(self.ratings_path)

        geo_calculator = GeoUtils()

        user_input, feature_weights, user_location = self.get_user_input()
        cars_df, ratings_df = load_data(self.cars_path, self.ratings_path)

        recommender = HybridRecommender(collaborative_model, geo_calculator)
        recommendations = recommender.recommend(self.user_id, user_input, feature_weights, user_location, cars_df)
        
        top_5 = recommendations[['make', 'model', 'price', 'fuel', 'year', 'kms', 
                                  'power', 'doors', 'shift', 'color', 'province', 
                                  'distance']].head(15)
        
        print("Hemos encontrado estos coches para ti:")
        print(top_5.to_string(index=False))


if __name__ == "__main__":
    app = CarRecommenderApp()
    app.run()




